/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/basic/gen-cpp/MyServiceEmpty.h"
#include <folly/ScopeGuard.h>

#include "thrift/compiler/test/fixtures/basic/gen-cpp/module_reflection.h"



int32_t MyServiceEmptyClient::getNextSendSequenceId()
{
  return nextSendSequenceId_++;
}

int32_t MyServiceEmptyClient::getNextRecvSequenceId()
{
  return nextRecvSequenceId_++;
}

const char* MyServiceEmptyClient::getServiceName() {
{
  return "MyServiceEmpty";
}
}
bool MyServiceEmptyProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& _fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(_fname);
  if (pfn == processMap_.end()) {
    iprot->skip(apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    apache::thrift::TApplicationException x(apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+_fname+"'");
    oprot->writeMessageBegin(_fname, apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  const ProcessFunction& pf = pfn->second;
  (this->*pf)(seqid, iprot, oprot, connectionContext);
  return true;
}

::std::shared_ptr< ::apache::thrift::TProcessor > MyServiceEmptyProcessorFactory::getProcessor(::apache::thrift::server::TConnectionContext* ctx) {
  ::apache::thrift::ReleaseHandler< MyServiceEmptyIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< MyServiceEmptyIf > handler(handlerFactory_->getHandler(ctx), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new MyServiceEmptyProcessor(handler));
  return processor;
}


