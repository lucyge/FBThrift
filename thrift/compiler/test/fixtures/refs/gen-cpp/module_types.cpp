/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_types.h"
#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_data.h"

#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>

#include <folly/Indestructible.h>



const typename _TypedEnum_EnumMapFactory::ValuesToNamesMapType _TypedEnum_VALUES_TO_NAMES = _TypedEnum_EnumMapFactory::makeValuesToNamesMap();

const typename _TypedEnum_EnumMapFactory::NamesToValuesMapType _TypedEnum_NAMES_TO_VALUES = _TypedEnum_EnumMapFactory::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::TypedEnum>::size = 2;
template <>const folly::Range<const  ::TypedEnum*> TEnumTraits< ::TypedEnum>::values = folly::range( ::_TypedEnumEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::TypedEnum>::names = folly::range( ::_TypedEnumEnumDataStorage::names);

template<>
const char* TEnumTraits< ::TypedEnum>::findName( ::TypedEnum value) {
  static const auto map = folly::Indestructible< ::_TypedEnum_EnumMapFactory::ValuesToNamesMapType>{ ::_TypedEnum_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::TypedEnum>::findValue(const char* name,  ::TypedEnum* out) {
  static const auto map = folly::Indestructible< ::_TypedEnum_EnumMapFactory::NamesToValuesMapType>{ ::_TypedEnum_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift


void MyUnion::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "anInteger") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "aString") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
};

uint32_t MyUnion::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_anInteger();
          xfer += iprot->readI32(this->value_.anInteger);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_STRING) {
          set_aString();
          xfer += iprot->readString(this->value_.aString);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MyUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyUnion");
  switch (type_) {
    case Type::anInteger: {
      xfer += oprot->writeFieldBegin("anInteger", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.anInteger);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::aString: {
      xfer += oprot->writeFieldBegin("aString", apache::thrift::protocol::T_STRING, 2);
      xfer += oprot->writeString(this->value_.aString);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t MyField::_reflection_id;
void MyField::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_16778989117799402412(schema);
}

bool MyField::operator == (const MyField & rhs) const {
  if (__isset.opt_value != rhs.__isset.opt_value)
    return false;
  else if (__isset.opt_value && !(opt_value == rhs.opt_value))
    return false;
  if (!(this->value == rhs.value))
    return false;
  if (!(this->req_value == rhs.req_value))
    return false;
  return true;
}

void MyField::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "opt_value") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "value") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "req_value") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
};

uint32_t MyField::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_16778989117799402412(*schema);
    iprot->setNextStructType(MyField::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->opt_value);
          this->__isset.opt_value = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->req_value);
          isset_req_value = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_value)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_value' was not found in serialized data! Struct: MyField");
  return xfer;
}

void MyField::__clear() {
  opt_value = 0;
  value = 0;
  req_value = 0;
  __isset.__clear();
}
uint32_t MyField::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyField");
  if (this->__isset.opt_value) {
    xfer += oprot->writeFieldBegin("opt_value", apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->opt_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("req_value", apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->req_value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyField &a, MyField &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_value, b.opt_value);
  swap(a.value, b.value);
  swap(a.req_value, b.req_value);
  swap(a.__isset, b.__isset);
}

void merge(const MyField& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(from.opt_value, to.opt_value);
    to.__isset.opt_value = true;
  }
  merge(from.value, to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(from.req_value, to.req_value);
}

void merge(MyField&& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(std::move(from.opt_value), to.opt_value);
    to.__isset.opt_value = true;
  }
  merge(std::move(from.value), to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(std::move(from.req_value), to.req_value);
}

const uint64_t MyStruct::_reflection_id;
void MyStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_7958971832214294220(schema);
}

MyStruct::MyStruct(const MyStruct& src1) {
  if (src1.opt_ref)
    opt_ref.reset(new MyField(*src1.opt_ref));
  if (src1.ref)
    ref.reset(new MyField(*src1.ref));
  if (src1.req_ref)
    req_ref.reset(new MyField(*src1.req_ref));
}
bool MyStruct::operator == (const MyStruct & rhs) const {
  if (bool(opt_ref) != bool(rhs.opt_ref))
    return false;
  else if (bool(opt_ref) && !(*opt_ref == *rhs.opt_ref))
    return false;
  if (bool(ref) != bool(rhs.ref))
    return false;
  else if (bool(ref) && !(*ref == *rhs.ref))
    return false;
  if (bool(req_ref) != bool(rhs.req_ref))
    return false;
  else if (bool(req_ref) && !(*req_ref == *rhs.req_ref))
    return false;
  return true;
}

void MyStruct::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "opt_ref") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ref") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_ref") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t MyStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_7958971832214294220(*schema);
    iprot->setNextStructType(MyStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;

  bool isset_req_ref = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype3(new element_type());
            xfer += _ptype3->read(iprot);
            this->opt_ref = std::move(_ptype3);
            if (false) {
            } else if (this->opt_ref->__isset.opt_value) {
            } else if (this->opt_ref->__isset.value) {
            } else { this->opt_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype4(new element_type());
            xfer += _ptype4->read(iprot);
            this->ref = std::move(_ptype4);
            if (false) {
            } else if (this->ref->__isset.opt_value) {
            } else if (this->ref->__isset.value) {
            } else { this->ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype5(new element_type());
            xfer += _ptype5->read(iprot);
            this->req_ref = std::move(_ptype5);
            if (false) {
            } else if (this->req_ref->__isset.opt_value) {
            } else if (this->req_ref->__isset.value) {
            } else { this->req_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          isset_req_ref = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  if (!isset_req_ref)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_ref' was not found in serialized data! Struct: MyStruct");
  return xfer;
}

void MyStruct::__clear() {
  if (opt_ref) opt_ref->__clear();
  if (ref) ref->__clear();
  if (req_ref) req_ref->__clear();
  __isset.__clear();
}
uint32_t MyStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyStruct");
  if (this->opt_ref) {
    xfer += oprot->writeFieldBegin("opt_ref", apache::thrift::protocol::T_STRUCT, 1);
    if (this->opt_ref) {xfer += this->opt_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->ref) {
    xfer += oprot->writeFieldBegin("ref", apache::thrift::protocol::T_STRUCT, 2);
    if (this->ref) {xfer += this->ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_ref) {
    xfer += oprot->writeFieldBegin("req_ref", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_ref) {xfer += this->req_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyStruct &a, MyStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_ref, b.opt_ref);
  swap(a.ref, b.ref);
  swap(a.req_ref, b.req_ref);
  swap(a.__isset, b.__isset);
}

void merge(const MyStruct& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(from.opt_ref, to.opt_ref);
  merge(from.ref, to.ref);
  merge(from.req_ref, to.req_ref);
}

void merge(MyStruct&& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(std::move(from.opt_ref), to.opt_ref);
  merge(std::move(from.ref), to.ref);
  merge(std::move(from.req_ref), to.req_ref);
}

const uint64_t StructWithUnion::_reflection_id;
void StructWithUnion::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_11295191354176986988(schema);
}

StructWithUnion::StructWithUnion(const StructWithUnion& src6) {
  if (src6.u)
    u.reset(new MyUnion(*src6.u));
  aDouble = src6.aDouble;
  __isset.aDouble = src6.__isset.aDouble;
  f = src6.f;
  __isset.f = src6.__isset.f;
}
bool StructWithUnion::operator == (const StructWithUnion & rhs) const {
  if (bool(u) != bool(rhs.u))
    return false;
  else if (bool(u) && !(*u == *rhs.u))
    return false;
  if (!(this->aDouble == rhs.aDouble))
    return false;
  if (!(this->f == rhs.f))
    return false;
  return true;
}

void StructWithUnion::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "u") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "aDouble") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "f") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithUnion::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_11295191354176986988(*schema);
    iprot->setNextStructType(StructWithUnion::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->u)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype8(new element_type());
          xfer += _ptype8->read(iprot);
          this->u = std::move(_ptype8);
          if (this->u->getType() == MyUnion::Type::__EMPTY__) {
            this->u = nullptr; 
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->aDouble);
          this->__isset.aDouble = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->f.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void StructWithUnion::__clear() {
  if (u) u->__clear();
  aDouble = 0;
  f.__clear();
  __isset.__clear();
}
uint32_t StructWithUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithUnion");
  if (this->u) {
    xfer += oprot->writeFieldBegin("u", apache::thrift::protocol::T_STRUCT, 1);
    if (this->u) {xfer += this->u->write(oprot); 
} else {oprot->writeStructBegin("MyUnion"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("aDouble", apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->aDouble);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->f.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithUnion &a, StructWithUnion &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.u, b.u);
  swap(a.aDouble, b.aDouble);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithUnion& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(from.u, to.u);
  merge(from.aDouble, to.aDouble);
  to.__isset.aDouble = to.__isset.aDouble || from.__isset.aDouble;
  merge(from.f, to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
}

void merge(StructWithUnion&& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(std::move(from.u), to.u);
  merge(std::move(from.aDouble), to.aDouble);
  to.__isset.aDouble = to.__isset.aDouble || from.__isset.aDouble;
  merge(std::move(from.f), to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
}

const uint64_t RecursiveStruct::_reflection_id;
void RecursiveStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_2826922994162023308(schema);
}

bool RecursiveStruct::operator == (const RecursiveStruct & rhs) const {
  if (__isset.mes != rhs.__isset.mes)
    return false;
  else if (__isset.mes && !(mes == rhs.mes))
    return false;
  return true;
}

void RecursiveStruct::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "mes") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_LIST;
  }
};

uint32_t RecursiveStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_2826922994162023308(*schema);
    iprot->setNextStructType(RecursiveStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->mes.clear();
            uint32_t _size10;
            bool _sizeUnknown11;
            apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size10, _sizeUnknown11);
            if (!_sizeUnknown11) {
              this->mes.resize(_size10);
              uint32_t _i16;
              for (_i16 = 0; _i16 < _size10; ++_i16)
              {
                xfer += this->mes[_i16].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                RecursiveStruct _elem17;
                xfer += _elem17.read(iprot);
                this->mes.push_back(_elem17);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mes = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void RecursiveStruct::__clear() {
  mes.clear();
  __isset.__clear();
}
uint32_t RecursiveStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecursiveStruct");
  if (this->__isset.mes) {
    xfer += oprot->writeFieldBegin("mes", apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->mes.size());
      std::vector<RecursiveStruct> ::const_iterator _iter18;
      for (_iter18 = this->mes.begin(); _iter18 != this->mes.end(); ++_iter18)
      {
        xfer += (*_iter18).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecursiveStruct &a, RecursiveStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.mes, b.mes);
  swap(a.__isset, b.__isset);
}

void merge(const RecursiveStruct& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(from.mes, to.mes);
    to.__isset.mes = true;
  }
}

void merge(RecursiveStruct&& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(std::move(from.mes), to.mes);
    to.__isset.mes = true;
  }
}

const uint64_t StructWithContainers::_reflection_id;
void StructWithContainers::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_18101585657679500556(schema);
}

StructWithContainers::StructWithContainers(const StructWithContainers& src19) {
  if (src19.list_ref)
    list_ref.reset(new std::vector<int32_t> (*src19.list_ref));
  if (src19.set_ref)
    set_ref.reset(new std::set<int32_t> (*src19.set_ref));
  if (src19.map_ref)
    map_ref.reset(new std::map<int32_t, int32_t> (*src19.map_ref));
  if (src19.list_ref_unique)
    list_ref_unique.reset(new std::vector<int32_t> (*src19.list_ref_unique));
  set_ref_shared = src19.set_ref_shared;
  list_ref_shared_const = src19.list_ref_shared_const;
}
bool StructWithContainers::operator == (const StructWithContainers & rhs) const {
  if (bool(list_ref) != bool(rhs.list_ref))
    return false;
  else if (bool(list_ref) && !(*list_ref == *rhs.list_ref))
    return false;
  if (bool(set_ref) != bool(rhs.set_ref))
    return false;
  else if (bool(set_ref) && !(*set_ref == *rhs.set_ref))
    return false;
  if (bool(map_ref) != bool(rhs.map_ref))
    return false;
  else if (bool(map_ref) && !(*map_ref == *rhs.map_ref))
    return false;
  if (bool(list_ref_unique) != bool(rhs.list_ref_unique))
    return false;
  else if (bool(list_ref_unique) && !(*list_ref_unique == *rhs.list_ref_unique))
    return false;
  if (bool(set_ref_shared) != bool(rhs.set_ref_shared))
    return false;
  else if (bool(set_ref_shared) && !(*set_ref_shared == *rhs.set_ref_shared))
    return false;
  if (bool(list_ref_shared_const) != bool(rhs.list_ref_shared_const))
    return false;
  else if (bool(list_ref_shared_const) && !(*list_ref_shared_const == *rhs.list_ref_shared_const))
    return false;
  return true;
}

void StructWithContainers::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "list_ref") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "set_ref") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "map_ref") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "list_ref_unique") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "set_ref_shared") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "list_ref_shared_const") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_LIST;
  }
};

uint32_t StructWithContainers::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_18101585657679500556(*schema);
    iprot->setNextStructType(StructWithContainers::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype26(new element_type());
            auto& _rtype27 = *_ptype26;
            _rtype27.clear();
            uint32_t _size21;
            bool _sizeUnknown22;
            apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size21, _sizeUnknown22);
            if (!_sizeUnknown22) {
              _rtype27.resize(_size21);
              uint32_t _i28;
              for (_i28 = 0; _i28 < _size21; ++_i28)
              {
                xfer += iprot->readI32(_rtype27[_i28]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem29;
                xfer += iprot->readI32(_elem29);
                _rtype27.push_back(_elem29);
              }
            }
            this->list_ref =  std::move(_ptype26);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->set_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype35(new element_type());
            auto& _rtype36 = *_ptype35;
            _rtype36.clear();
            uint32_t _size30;
            bool _sizeUnknown31;
            apache::thrift::protocol::TType _etype34;
            xfer += iprot->readSetBegin(_etype34, _size30, _sizeUnknown31);
            if (!_sizeUnknown31) {
              uint32_t _i37;
              for (_i37 = 0; _i37 < _size30; ++_i37)
              {
                int32_t _elem38;
                xfer += iprot->readI32(_elem38);
                _rtype36.insert(_elem38);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem39;
                xfer += iprot->readI32(_elem39);
                _rtype36.insert(_elem39);
              }
            }
            this->set_ref =  std::move(_ptype35);
            xfer += iprot->readSetEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->map_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype45(new element_type());
            auto& _rtype46 = *_ptype45;
            _rtype46.clear();
            uint32_t _size40;
            bool _sizeUnknown41;
            apache::thrift::protocol::TType _ktype42 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype43 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size40, _sizeUnknown41);
            if (!_sizeUnknown41) {
              uint32_t _i47;
              for (_i47 = 0; _i47 < _size40; ++_i47)
              {
                int32_t _key48;
                xfer += iprot->readI32(_key48);
                int32_t& _val49 = _rtype46[_key48];
                xfer += iprot->readI32(_val49);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key50;
                xfer += iprot->readI32(_key50);
                int32_t& _val51 = _rtype46[_key50];
                xfer += iprot->readI32(_val51);
              }
            }
            this->map_ref =  std::move(_ptype45);
            xfer += iprot->readMapEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref_unique)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype57(new element_type());
            auto& _rtype58 = *_ptype57;
            _rtype58.clear();
            uint32_t _size52;
            bool _sizeUnknown53;
            apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size52, _sizeUnknown53);
            if (!_sizeUnknown53) {
              _rtype58.resize(_size52);
              uint32_t _i59;
              for (_i59 = 0; _i59 < _size52; ++_i59)
              {
                xfer += iprot->readI32(_rtype58[_i59]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem60;
                xfer += iprot->readI32(_elem60);
                _rtype58.push_back(_elem60);
              }
            }
            this->list_ref_unique =  std::move(_ptype57);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->set_ref_shared)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype66(new element_type());
            auto& _rtype67 = *_ptype66;
            _rtype67.clear();
            uint32_t _size61;
            bool _sizeUnknown62;
            apache::thrift::protocol::TType _etype65;
            xfer += iprot->readSetBegin(_etype65, _size61, _sizeUnknown62);
            if (!_sizeUnknown62) {
              uint32_t _i68;
              for (_i68 = 0; _i68 < _size61; ++_i68)
              {
                int32_t _elem69;
                xfer += iprot->readI32(_elem69);
                _rtype67.insert(_elem69);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem70;
                xfer += iprot->readI32(_elem70);
                _rtype67.insert(_elem70);
              }
            }
            this->set_ref_shared =  std::move(_ptype66);
            xfer += iprot->readSetEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype76(new element_type());
            auto& _rtype77 = *_ptype76;
            _rtype77.clear();
            uint32_t _size71;
            bool _sizeUnknown72;
            apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size71, _sizeUnknown72);
            if (!_sizeUnknown72) {
              _rtype77.resize(_size71);
              uint32_t _i78;
              for (_i78 = 0; _i78 < _size71; ++_i78)
              {
                xfer += iprot->readI32(_rtype77[_i78]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem79;
                xfer += iprot->readI32(_elem79);
                _rtype77.push_back(_elem79);
              }
            }
            this->list_ref_shared_const =  std::move(_ptype76);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void StructWithContainers::__clear() {
  list_ref.reset(new typename decltype(list_ref)::element_type());
  set_ref.reset(new typename decltype(set_ref)::element_type());
  map_ref.reset(new typename decltype(map_ref)::element_type());
  list_ref_unique.reset(new typename decltype(list_ref_unique)::element_type());
  set_ref_shared.reset(new typename decltype(set_ref_shared)::element_type());
  list_ref_shared_const.reset(new typename decltype(list_ref_shared_const)::element_type());
  __isset.__clear();
}
uint32_t StructWithContainers::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithContainers");
  if (this->list_ref) {
    xfer += oprot->writeFieldBegin("list_ref", apache::thrift::protocol::T_LIST, 1);
    {
      if (this->list_ref) {
        const auto& _rtype80 = *this->list_ref;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype80.size());
        std::vector<int32_t> ::const_iterator _iter81;
        for (_iter81 = _rtype80.begin(); _iter81 != _rtype80.end(); ++_iter81)
        {
          xfer += oprot->writeI32((*_iter81));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->set_ref) {
    xfer += oprot->writeFieldBegin("set_ref", apache::thrift::protocol::T_SET, 2);
    {
      if (this->set_ref) {
        const auto& _rtype82 = *this->set_ref;
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, _rtype82.size());
        std::set<int32_t> ::const_iterator _iter83;
        for (_iter83 = _rtype82.begin(); _iter83 != _rtype82.end(); ++_iter83)
        {
          xfer += oprot->writeI32((*_iter83));
        }
        xfer += oprot->writeSetEnd();
      } else {
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->map_ref) {
    xfer += oprot->writeFieldBegin("map_ref", apache::thrift::protocol::T_MAP, 3);
    {
      if (this->map_ref) {
        const auto& _rtype84 = *this->map_ref;
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, _rtype84.size());
        std::map<int32_t, int32_t> ::const_iterator _iter85;
        for (_iter85 = _rtype84.begin(); _iter85 != _rtype84.end(); ++_iter85)
        {
          xfer += oprot->writeI32(_iter85->first);
          xfer += oprot->writeI32(_iter85->second);
        }
        xfer += oprot->writeMapEnd();
      } else {
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->list_ref_unique) {
    xfer += oprot->writeFieldBegin("list_ref_unique", apache::thrift::protocol::T_LIST, 4);
    {
      if (this->list_ref_unique) {
        const auto& _rtype86 = *this->list_ref_unique;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype86.size());
        std::vector<int32_t> ::const_iterator _iter87;
        for (_iter87 = _rtype86.begin(); _iter87 != _rtype86.end(); ++_iter87)
        {
          xfer += oprot->writeI32((*_iter87));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->set_ref_shared) {
    xfer += oprot->writeFieldBegin("set_ref_shared", apache::thrift::protocol::T_SET, 5);
    {
      if (this->set_ref_shared) {
        const auto& _rtype88 = *this->set_ref_shared;
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, _rtype88.size());
        std::set<int32_t> ::const_iterator _iter89;
        for (_iter89 = _rtype88.begin(); _iter89 != _rtype88.end(); ++_iter89)
        {
          xfer += oprot->writeI32((*_iter89));
        }
        xfer += oprot->writeSetEnd();
      } else {
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->list_ref_shared_const) {
    xfer += oprot->writeFieldBegin("list_ref_shared_const", apache::thrift::protocol::T_LIST, 6);
    {
      if (this->list_ref_shared_const) {
        const auto& _rtype90 = *this->list_ref_shared_const;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype90.size());
        std::vector<int32_t> ::const_iterator _iter91;
        for (_iter91 = _rtype90.begin(); _iter91 != _rtype90.end(); ++_iter91)
        {
          xfer += oprot->writeI32((*_iter91));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithContainers &a, StructWithContainers &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.list_ref, b.list_ref);
  swap(a.set_ref, b.set_ref);
  swap(a.map_ref, b.map_ref);
  swap(a.list_ref_unique, b.list_ref_unique);
  swap(a.set_ref_shared, b.set_ref_shared);
  swap(a.list_ref_shared_const, b.list_ref_shared_const);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithContainers& from, StructWithContainers& to) {
  using apache::thrift::merge;
  merge(from.list_ref, to.list_ref);
  merge(from.set_ref, to.set_ref);
  merge(from.map_ref, to.map_ref);
  merge(from.list_ref_unique, to.list_ref_unique);
  merge(from.set_ref_shared, to.set_ref_shared);
  merge(from.list_ref_shared_const, to.list_ref_shared_const);
}

void merge(StructWithContainers&& from, StructWithContainers& to) {
  using apache::thrift::merge;
  merge(std::move(from.list_ref), to.list_ref);
  merge(std::move(from.set_ref), to.set_ref);
  merge(std::move(from.map_ref), to.map_ref);
  merge(std::move(from.list_ref_unique), to.list_ref_unique);
  merge(std::move(from.set_ref_shared), to.set_ref_shared);
  merge(std::move(from.list_ref_shared_const), to.list_ref_shared_const);
}

const uint64_t StructWithSharedConst::_reflection_id;
void StructWithSharedConst::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_17232433652683371404(schema);
}

bool StructWithSharedConst::operator == (const StructWithSharedConst & rhs) const {
  if (bool(opt_shared_const) != bool(rhs.opt_shared_const))
    return false;
  else if (bool(opt_shared_const) && !(*opt_shared_const == *rhs.opt_shared_const))
    return false;
  if (bool(shared_const) != bool(rhs.shared_const))
    return false;
  else if (bool(shared_const) && !(*shared_const == *rhs.shared_const))
    return false;
  if (bool(req_shared_const) != bool(rhs.req_shared_const))
    return false;
  else if (bool(req_shared_const) && !(*req_shared_const == *rhs.req_shared_const))
    return false;
  return true;
}

void StructWithSharedConst::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "opt_shared_const") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "shared_const") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_shared_const") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithSharedConst::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_17232433652683371404(*schema);
    iprot->setNextStructType(StructWithSharedConst::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;

  bool isset_req_shared_const = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype93(new element_type());
            xfer += _ptype93->read(iprot);
            this->opt_shared_const = std::move(_ptype93);
            if (false) {
            } else if (this->opt_shared_const->__isset.opt_value) {
            } else if (this->opt_shared_const->__isset.value) {
            } else { this->opt_shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype94(new element_type());
            xfer += _ptype94->read(iprot);
            this->shared_const = std::move(_ptype94);
            if (false) {
            } else if (this->shared_const->__isset.opt_value) {
            } else if (this->shared_const->__isset.value) {
            } else { this->shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype95(new element_type());
            xfer += _ptype95->read(iprot);
            this->req_shared_const = std::move(_ptype95);
            if (false) {
            } else if (this->req_shared_const->__isset.opt_value) {
            } else if (this->req_shared_const->__isset.value) {
            } else { this->req_shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          isset_req_shared_const = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  if (!isset_req_shared_const)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_shared_const' was not found in serialized data! Struct: StructWithSharedConst");
  return xfer;
}

void StructWithSharedConst::__clear() {
  opt_shared_const.reset();
  shared_const.reset();
  req_shared_const.reset();
  __isset.__clear();
}
uint32_t StructWithSharedConst::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithSharedConst");
  if (this->opt_shared_const) {
    xfer += oprot->writeFieldBegin("opt_shared_const", apache::thrift::protocol::T_STRUCT, 1);
    if (this->opt_shared_const) {xfer += this->opt_shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->shared_const) {
    xfer += oprot->writeFieldBegin("shared_const", apache::thrift::protocol::T_STRUCT, 2);
    if (this->shared_const) {xfer += this->shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_shared_const) {
    xfer += oprot->writeFieldBegin("req_shared_const", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_shared_const) {xfer += this->req_shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithSharedConst &a, StructWithSharedConst &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_shared_const, b.opt_shared_const);
  swap(a.shared_const, b.shared_const);
  swap(a.req_shared_const, b.req_shared_const);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithSharedConst& from, StructWithSharedConst& to) {
  using apache::thrift::merge;
  merge(from.opt_shared_const, to.opt_shared_const);
  merge(from.shared_const, to.shared_const);
  merge(from.req_shared_const, to.req_shared_const);
}

void merge(StructWithSharedConst&& from, StructWithSharedConst& to) {
  using apache::thrift::merge;
  merge(std::move(from.opt_shared_const), to.opt_shared_const);
  merge(std::move(from.shared_const), to.shared_const);
  merge(std::move(from.req_shared_const), to.req_shared_const);
}

const uint64_t Empty::_reflection_id;
void Empty::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_14313748354111837868(schema);
}

bool Empty::operator == (const Empty & rhs) const {
  (void)rhs;
  return true;
}

void Empty::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
};

uint32_t Empty::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_14313748354111837868(*schema);
    iprot->setNextStructType(Empty::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void Empty::__clear() {
}
uint32_t Empty::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Empty");
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Empty &a, Empty &b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

void merge(const Empty& from, Empty& to) {
  using apache::thrift::merge;
  (void)from;
  (void)to;
}

void merge(Empty&& from, Empty& to) {
  using apache::thrift::merge;
  (void)from;
  (void)to;
}

const uint64_t StructWithRef::_reflection_id;
void StructWithRef::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_11749517231251122252(schema);
}

StructWithRef::StructWithRef(const StructWithRef& src97) {
  if (src97.def_field)
    def_field.reset(new Empty(*src97.def_field));
  if (src97.opt_field)
    opt_field.reset(new Empty(*src97.opt_field));
  if (src97.req_field)
    req_field.reset(new Empty(*src97.req_field));
}
bool StructWithRef::operator == (const StructWithRef & rhs) const {
  if (bool(def_field) != bool(rhs.def_field))
    return false;
  else if (bool(def_field) && !(*def_field == *rhs.def_field))
    return false;
  if (bool(opt_field) != bool(rhs.opt_field))
    return false;
  else if (bool(opt_field) && !(*opt_field == *rhs.opt_field))
    return false;
  if (bool(req_field) != bool(rhs.req_field))
    return false;
  else if (bool(req_field) && !(*req_field == *rhs.req_field))
    return false;
  return true;
}

void StructWithRef::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "def_field") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_field") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_field") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithRef::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_11749517231251122252(*schema);
    iprot->setNextStructType(StructWithRef::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->def_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype99(new element_type());
          xfer += _ptype99->read(iprot);
          this->def_field = std::move(_ptype99);
          if (false) {
          } else { this->def_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype100(new element_type());
          xfer += _ptype100->read(iprot);
          this->opt_field = std::move(_ptype100);
          if (false) {
          } else { this->opt_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype101(new element_type());
          xfer += _ptype101->read(iprot);
          this->req_field = std::move(_ptype101);
          if (false) {
          } else { this->req_field = nullptr; }
          isset_req_field = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_field)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_field' was not found in serialized data! Struct: StructWithRef");
  return xfer;
}

void StructWithRef::__clear() {
  if (def_field) def_field->__clear();
  if (opt_field) opt_field->__clear();
  if (req_field) req_field->__clear();
  __isset.__clear();
}
uint32_t StructWithRef::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithRef");
  if (this->def_field) {
    xfer += oprot->writeFieldBegin("def_field", apache::thrift::protocol::T_STRUCT, 1);
    if (this->def_field) {xfer += this->def_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->opt_field) {
    xfer += oprot->writeFieldBegin("opt_field", apache::thrift::protocol::T_STRUCT, 2);
    if (this->opt_field) {xfer += this->opt_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_field) {
    xfer += oprot->writeFieldBegin("req_field", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_field) {xfer += this->req_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithRef &a, StructWithRef &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithRef& from, StructWithRef& to) {
  using apache::thrift::merge;
  merge(from.def_field, to.def_field);
  merge(from.opt_field, to.opt_field);
  merge(from.req_field, to.req_field);
}

void merge(StructWithRef&& from, StructWithRef& to) {
  using apache::thrift::merge;
  merge(std::move(from.def_field), to.def_field);
  merge(std::move(from.opt_field), to.opt_field);
  merge(std::move(from.req_field), to.req_field);
}

const uint64_t StructWithRefTypeUnique::_reflection_id;
void StructWithRefTypeUnique::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_215755688094406540(schema);
}

StructWithRefTypeUnique::StructWithRefTypeUnique(const StructWithRefTypeUnique& src102) {
  if (src102.def_field)
    def_field.reset(new Empty(*src102.def_field));
  if (src102.opt_field)
    opt_field.reset(new Empty(*src102.opt_field));
  if (src102.req_field)
    req_field.reset(new Empty(*src102.req_field));
}
bool StructWithRefTypeUnique::operator == (const StructWithRefTypeUnique & rhs) const {
  if (bool(def_field) != bool(rhs.def_field))
    return false;
  else if (bool(def_field) && !(*def_field == *rhs.def_field))
    return false;
  if (bool(opt_field) != bool(rhs.opt_field))
    return false;
  else if (bool(opt_field) && !(*opt_field == *rhs.opt_field))
    return false;
  if (bool(req_field) != bool(rhs.req_field))
    return false;
  else if (bool(req_field) && !(*req_field == *rhs.req_field))
    return false;
  return true;
}

void StructWithRefTypeUnique::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "def_field") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_field") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_field") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithRefTypeUnique::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_215755688094406540(*schema);
    iprot->setNextStructType(StructWithRefTypeUnique::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->def_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype104(new element_type());
          xfer += _ptype104->read(iprot);
          this->def_field = std::move(_ptype104);
          if (false) {
          } else { this->def_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype105(new element_type());
          xfer += _ptype105->read(iprot);
          this->opt_field = std::move(_ptype105);
          if (false) {
          } else { this->opt_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype106(new element_type());
          xfer += _ptype106->read(iprot);
          this->req_field = std::move(_ptype106);
          if (false) {
          } else { this->req_field = nullptr; }
          isset_req_field = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_field)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_field' was not found in serialized data! Struct: StructWithRefTypeUnique");
  return xfer;
}

void StructWithRefTypeUnique::__clear() {
  if (def_field) def_field->__clear();
  if (opt_field) opt_field->__clear();
  if (req_field) req_field->__clear();
  __isset.__clear();
}
uint32_t StructWithRefTypeUnique::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithRefTypeUnique");
  if (this->def_field) {
    xfer += oprot->writeFieldBegin("def_field", apache::thrift::protocol::T_STRUCT, 1);
    if (this->def_field) {xfer += this->def_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->opt_field) {
    xfer += oprot->writeFieldBegin("opt_field", apache::thrift::protocol::T_STRUCT, 2);
    if (this->opt_field) {xfer += this->opt_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_field) {
    xfer += oprot->writeFieldBegin("req_field", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_field) {xfer += this->req_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithRefTypeUnique &a, StructWithRefTypeUnique &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithRefTypeUnique& from, StructWithRefTypeUnique& to) {
  using apache::thrift::merge;
  merge(from.def_field, to.def_field);
  merge(from.opt_field, to.opt_field);
  merge(from.req_field, to.req_field);
}

void merge(StructWithRefTypeUnique&& from, StructWithRefTypeUnique& to) {
  using apache::thrift::merge;
  merge(std::move(from.def_field), to.def_field);
  merge(std::move(from.opt_field), to.opt_field);
  merge(std::move(from.req_field), to.req_field);
}

const uint64_t StructWithRefTypeShared::_reflection_id;
void StructWithRefTypeShared::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_12352376109981065772(schema);
}

bool StructWithRefTypeShared::operator == (const StructWithRefTypeShared & rhs) const {
  if (bool(def_field) != bool(rhs.def_field))
    return false;
  else if (bool(def_field) && !(*def_field == *rhs.def_field))
    return false;
  if (bool(opt_field) != bool(rhs.opt_field))
    return false;
  else if (bool(opt_field) && !(*opt_field == *rhs.opt_field))
    return false;
  if (bool(req_field) != bool(rhs.req_field))
    return false;
  else if (bool(req_field) && !(*req_field == *rhs.req_field))
    return false;
  return true;
}

void StructWithRefTypeShared::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "def_field") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_field") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_field") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithRefTypeShared::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_12352376109981065772(*schema);
    iprot->setNextStructType(StructWithRefTypeShared::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->def_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype108(new element_type());
          xfer += _ptype108->read(iprot);
          this->def_field = std::move(_ptype108);
          if (false) {
          } else { this->def_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype109(new element_type());
          xfer += _ptype109->read(iprot);
          this->opt_field = std::move(_ptype109);
          if (false) {
          } else { this->opt_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype110(new element_type());
          xfer += _ptype110->read(iprot);
          this->req_field = std::move(_ptype110);
          if (false) {
          } else { this->req_field = nullptr; }
          isset_req_field = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_field)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_field' was not found in serialized data! Struct: StructWithRefTypeShared");
  return xfer;
}

void StructWithRefTypeShared::__clear() {
  if (def_field) def_field->__clear();
  if (opt_field) opt_field->__clear();
  if (req_field) req_field->__clear();
  __isset.__clear();
}
uint32_t StructWithRefTypeShared::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithRefTypeShared");
  if (this->def_field) {
    xfer += oprot->writeFieldBegin("def_field", apache::thrift::protocol::T_STRUCT, 1);
    if (this->def_field) {xfer += this->def_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->opt_field) {
    xfer += oprot->writeFieldBegin("opt_field", apache::thrift::protocol::T_STRUCT, 2);
    if (this->opt_field) {xfer += this->opt_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_field) {
    xfer += oprot->writeFieldBegin("req_field", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_field) {xfer += this->req_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithRefTypeShared &a, StructWithRefTypeShared &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithRefTypeShared& from, StructWithRefTypeShared& to) {
  using apache::thrift::merge;
  merge(from.def_field, to.def_field);
  merge(from.opt_field, to.opt_field);
  merge(from.req_field, to.req_field);
}

void merge(StructWithRefTypeShared&& from, StructWithRefTypeShared& to) {
  using apache::thrift::merge;
  merge(std::move(from.def_field), to.def_field);
  merge(std::move(from.opt_field), to.opt_field);
  merge(std::move(from.req_field), to.req_field);
}

const uint64_t StructWithRefTypeSharedConst::_reflection_id;
void StructWithRefTypeSharedConst::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_11678635121852876428(schema);
}

bool StructWithRefTypeSharedConst::operator == (const StructWithRefTypeSharedConst & rhs) const {
  if (bool(def_field) != bool(rhs.def_field))
    return false;
  else if (bool(def_field) && !(*def_field == *rhs.def_field))
    return false;
  if (bool(opt_field) != bool(rhs.opt_field))
    return false;
  else if (bool(opt_field) && !(*opt_field == *rhs.opt_field))
    return false;
  if (bool(req_field) != bool(rhs.req_field))
    return false;
  else if (bool(req_field) && !(*req_field == *rhs.req_field))
    return false;
  return true;
}

void StructWithRefTypeSharedConst::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "def_field") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_field") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_field") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
};

uint32_t StructWithRefTypeSharedConst::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_11678635121852876428(*schema);
    iprot->setNextStructType(StructWithRefTypeSharedConst::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->def_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype112(new element_type());
          xfer += _ptype112->read(iprot);
          this->def_field = std::move(_ptype112);
          if (false) {
          } else { this->def_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype113(new element_type());
          xfer += _ptype113->read(iprot);
          this->opt_field = std::move(_ptype113);
          if (false) {
          } else { this->opt_field = nullptr; }
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_field)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype114(new element_type());
          xfer += _ptype114->read(iprot);
          this->req_field = std::move(_ptype114);
          if (false) {
          } else { this->req_field = nullptr; }
          isset_req_field = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_field)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_field' was not found in serialized data! Struct: StructWithRefTypeSharedConst");
  return xfer;
}

void StructWithRefTypeSharedConst::__clear() {
  def_field.reset();
  opt_field.reset();
  req_field.reset();
  __isset.__clear();
}
uint32_t StructWithRefTypeSharedConst::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithRefTypeSharedConst");
  if (this->def_field) {
    xfer += oprot->writeFieldBegin("def_field", apache::thrift::protocol::T_STRUCT, 1);
    if (this->def_field) {xfer += this->def_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->opt_field) {
    xfer += oprot->writeFieldBegin("opt_field", apache::thrift::protocol::T_STRUCT, 2);
    if (this->opt_field) {xfer += this->opt_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_field) {
    xfer += oprot->writeFieldBegin("req_field", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_field) {xfer += this->req_field->write(oprot); 
} else {oprot->writeStructBegin("Empty"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithRefTypeSharedConst &a, StructWithRefTypeSharedConst &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithRefTypeSharedConst& from, StructWithRefTypeSharedConst& to) {
  using apache::thrift::merge;
  merge(from.def_field, to.def_field);
  merge(from.opt_field, to.opt_field);
  merge(from.req_field, to.req_field);
}

void merge(StructWithRefTypeSharedConst&& from, StructWithRefTypeSharedConst& to) {
  using apache::thrift::merge;
  merge(std::move(from.def_field), to.def_field);
  merge(std::move(from.opt_field), to.opt_field);
  merge(std::move(from.req_field), to.req_field);
}


