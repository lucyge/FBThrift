#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins




cdef cOldStructure _OldStructure_defaults = cOldStructure()

cdef class OldStructure(thrift.py3.types.Struct):

    def __init__(
        OldStructure self, *,
        features=None
    ):
        self._cpp_obj = move(OldStructure._make_instance(
          NULL,
          features,
        ))

    def __call__(
        OldStructure self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <OldStructure>OldStructure.__new__(OldStructure)
        inst._cpp_obj = move(OldStructure._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cOldStructure] _make_instance(
        cOldStructure* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cOldStructure] c_inst
        if base_instance:
            c_inst = make_unique[cOldStructure](deref(base_instance))
        else:
            c_inst = make_unique[cOldStructure]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _OldStructure_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = <cmap[int16_t,double]>deref(Map__i16_double(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cOldStructure] cpp_obj):
        inst = <OldStructure>OldStructure.__new__(OldStructure)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_double.create(make_shared[cmap[int16_t,double]](deref(self._cpp_obj).features))
        return self.__features


    def __hash__(OldStructure self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(OldStructure self):
        return f'OldStructure(features={repr(self.features)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, OldStructure) and
                isinstance(other, OldStructure)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cOldStructure cself = deref((<OldStructure>self)._cpp_obj)
        cdef cOldStructure cother = deref((<OldStructure>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(OldStructure self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cOldStructure](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cOldStructure](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cOldStructure](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(OldStructure self, const IOBuf* buf, proto):
        cdef uint32_t needed
        self._cpp_obj = make_shared[cOldStructure]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cOldStructure](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cOldStructure](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cOldStructure](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (OldStructure, serialize(self)))


cdef cNewStructure _NewStructure_defaults = cNewStructure()

cdef class NewStructure(thrift.py3.types.Struct):

    def __init__(
        NewStructure self, *,
        features=None
    ):
        self._cpp_obj = move(NewStructure._make_instance(
          NULL,
          features,
        ))

    def __call__(
        NewStructure self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructure>NewStructure.__new__(NewStructure)
        inst._cpp_obj = move(NewStructure._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructure] _make_instance(
        cNewStructure* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cNewStructure] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructure](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructure]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _NewStructure_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = <cmap[int16_t,double]>deref(Map__i16_double(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructure] cpp_obj):
        inst = <NewStructure>NewStructure.__new__(NewStructure)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_double.create(make_shared[cmap[int16_t,double]](deref(self._cpp_obj).features))
        return self.__features


    def __hash__(NewStructure self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(NewStructure self):
        return f'NewStructure(features={repr(self.features)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, NewStructure) and
                isinstance(other, NewStructure)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cNewStructure cself = deref((<NewStructure>self)._cpp_obj)
        cdef cNewStructure cother = deref((<NewStructure>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(NewStructure self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cNewStructure](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cNewStructure](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cNewStructure](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(NewStructure self, const IOBuf* buf, proto):
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructure]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cNewStructure](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cNewStructure](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cNewStructure](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructure, serialize(self)))


cdef cNewStructure2 _NewStructure2_defaults = cNewStructure2()

cdef class NewStructure2(thrift.py3.types.Struct):

    def __init__(
        NewStructure2 self, *,
        features=None
    ):
        self._cpp_obj = move(NewStructure2._make_instance(
          NULL,
          features,
        ))

    def __call__(
        NewStructure2 self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructure2>NewStructure2.__new__(NewStructure2)
        inst._cpp_obj = move(NewStructure2._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructure2] _make_instance(
        cNewStructure2* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cNewStructure2] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructure2](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructure2]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _NewStructure2_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = <cmap[int16_t,float]>deref(Map__i16_float(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructure2] cpp_obj):
        inst = <NewStructure2>NewStructure2.__new__(NewStructure2)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_float.create(make_shared[cmap[int16_t,float]](deref(self._cpp_obj).features))
        return self.__features


    def __hash__(NewStructure2 self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(NewStructure2 self):
        return f'NewStructure2(features={repr(self.features)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, NewStructure2) and
                isinstance(other, NewStructure2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cNewStructure2 cself = deref((<NewStructure2>self)._cpp_obj)
        cdef cNewStructure2 cother = deref((<NewStructure2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(NewStructure2 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cNewStructure2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cNewStructure2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cNewStructure2](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(NewStructure2 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructure2]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cNewStructure2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cNewStructure2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cNewStructure2](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructure2, serialize(self)))


cdef cNewStructureNested _NewStructureNested_defaults = cNewStructureNested()

cdef class NewStructureNested(thrift.py3.types.Struct):

    def __init__(
        NewStructureNested self, *,
        lst=None,
        mp=None,
        s=None
    ):
        self._cpp_obj = move(NewStructureNested._make_instance(
          NULL,
          lst,
          mp,
          s,
        ))

    def __call__(
        NewStructureNested self,
        lst=__NOTSET,
        mp=__NOTSET,
        s=__NOTSET
    ):
        changes = any((
            lst is not __NOTSET,

            mp is not __NOTSET,

            s is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructureNested>NewStructureNested.__new__(NewStructureNested)
        inst._cpp_obj = move(NewStructureNested._make_instance(
          self._cpp_obj.get(),
          lst,
          mp,
          s,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructureNested] _make_instance(
        cNewStructureNested* base_instance,
        object lst,
        object mp,
        object s
    ) except *:
        cdef unique_ptr[cNewStructureNested] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructureNested](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructureNested]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if lst is None:
                deref(c_inst).lst = _NewStructureNested_defaults.lst
                deref(c_inst).__isset.lst = False
                pass
            elif lst is __NOTSET:
                lst = None

            if mp is None:
                deref(c_inst).mp = _NewStructureNested_defaults.mp
                deref(c_inst).__isset.mp = False
                pass
            elif mp is __NOTSET:
                mp = None

            if s is None:
                deref(c_inst).s = _NewStructureNested_defaults.s
                deref(c_inst).__isset.s = False
                pass
            elif s is __NOTSET:
                s = None

        if lst is not None:
            deref(c_inst).lst = <vector[cmap[int16_t,float]]>deref(List__Map__i16_float(lst)._cpp_obj)
            deref(c_inst).__isset.lst = True
        if mp is not None:
            deref(c_inst).mp = <cmap[int16_t,cmap[int16_t,float]]>deref(Map__i16_Map__i16_float(mp)._cpp_obj)
            deref(c_inst).__isset.mp = True
        if s is not None:
            deref(c_inst).s = <cset[cmap[int16_t,float]]>deref(Set__Map__i16_float(s)._cpp_obj)
            deref(c_inst).__isset.s = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'lst', self.lst
        yield 'mp', self.mp
        yield 's', self.s

    def __bool__(self):
        return True or True or True

    @staticmethod
    cdef create(shared_ptr[cNewStructureNested] cpp_obj):
        inst = <NewStructureNested>NewStructureNested.__new__(NewStructureNested)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def lst(self):

        if self.__lst is None:
            self.__lst = List__Map__i16_float.create(make_shared[vector[cmap[int16_t,float]]](deref(self._cpp_obj).lst))
        return self.__lst

    @property
    def mp(self):

        if self.__mp is None:
            self.__mp = Map__i16_Map__i16_float.create(make_shared[cmap[int16_t,cmap[int16_t,float]]](deref(self._cpp_obj).mp))
        return self.__mp

    @property
    def s(self):

        if self.__s is None:
            self.__s = Set__Map__i16_float.create(make_shared[cset[cmap[int16_t,float]]](deref(self._cpp_obj).s))
        return self.__s


    def __hash__(NewStructureNested self):
        if not self.__hash:
            self.__hash = hash((
            self.lst,
            self.mp,
            self.s,
            ))
        return self.__hash

    def __repr__(NewStructureNested self):
        return f'NewStructureNested(lst={repr(self.lst)}, mp={repr(self.mp)}, s={repr(self.s)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, NewStructureNested) and
                isinstance(other, NewStructureNested)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cNewStructureNested cself = deref((<NewStructureNested>self)._cpp_obj)
        cdef cNewStructureNested cother = deref((<NewStructureNested>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(NewStructureNested self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cNewStructureNested](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cNewStructureNested](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cNewStructureNested](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(NewStructureNested self, const IOBuf* buf, proto):
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructureNested]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cNewStructureNested](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cNewStructureNested](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cNewStructureNested](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructureNested, serialize(self)))


cdef cNewStructureNestedField _NewStructureNestedField_defaults = cNewStructureNestedField()

cdef class NewStructureNestedField(thrift.py3.types.Struct):

    def __init__(
        NewStructureNestedField self, *,
        NewStructureNested f=None
    ):
        self._cpp_obj = move(NewStructureNestedField._make_instance(
          NULL,
          f,
        ))

    def __call__(
        NewStructureNestedField self,
        f=__NOTSET
    ):
        changes = any((
            f is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not f is not __NOTSET:
            if not isinstance(f, NewStructureNested):
                raise TypeError(f'f is not a { NewStructureNested !r}.')

        inst = <NewStructureNestedField>NewStructureNestedField.__new__(NewStructureNestedField)
        inst._cpp_obj = move(NewStructureNestedField._make_instance(
          self._cpp_obj.get(),
          f,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructureNestedField] _make_instance(
        cNewStructureNestedField* base_instance,
        object f
    ) except *:
        cdef unique_ptr[cNewStructureNestedField] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructureNestedField](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructureNestedField]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if f is None:
                deref(c_inst).f = _NewStructureNestedField_defaults.f
                deref(c_inst).__isset.f = False
                pass
            elif f is __NOTSET:
                f = None

        if f is not None:
            deref(c_inst).f = deref((<NewStructureNested?> f)._cpp_obj)
            deref(c_inst).__isset.f = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'f', self.f

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructureNestedField] cpp_obj):
        inst = <NewStructureNestedField>NewStructureNestedField.__new__(NewStructureNestedField)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def f(self):

        if self.__f is None:
            self.__f = NewStructureNested.create(make_shared[cNewStructureNested](deref(self._cpp_obj).f))
        return self.__f


    def __hash__(NewStructureNestedField self):
        if not self.__hash:
            self.__hash = hash((
            self.f,
            ))
        return self.__hash

    def __repr__(NewStructureNestedField self):
        return f'NewStructureNestedField(f={repr(self.f)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, NewStructureNestedField) and
                isinstance(other, NewStructureNestedField)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cNewStructureNestedField cself = deref((<NewStructureNestedField>self)._cpp_obj)
        cdef cNewStructureNestedField cother = deref((<NewStructureNestedField>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(NewStructureNestedField self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cNewStructureNestedField](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cNewStructureNestedField](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cNewStructureNestedField](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(NewStructureNestedField self, const IOBuf* buf, proto):
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructureNestedField]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cNewStructureNestedField](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cNewStructureNestedField](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cNewStructureNestedField](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructureNestedField, serialize(self)))


cdef class Map__i16_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_double):
            self._cpp_obj = (<Map__i16_double> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i16_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,double]] c_items):
        inst = <Map__i16_double>Map__i16_double.__new__(Map__i16_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int16_t,double]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int16_t,double]] c_inst = make_unique[cmap[int16_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int16_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst).insert(cpair[int16_t,double](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int16_t ckey = key
        cdef cmap[int16_t,double].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int16_t ckey = key
        cdef cmap[int16_t,double].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef double citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef double citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i16_double)

cdef class Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_float):
            self._cpp_obj = (<Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i16_float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,float]] c_items):
        inst = <Map__i16_float>Map__i16_float.__new__(Map__i16_float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int16_t,float]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int16_t,float]] c_inst = make_unique[cmap[int16_t,float]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int16_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst).insert(cpair[int16_t,float](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int16_t ckey = key
        cdef cmap[int16_t,float].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef float citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int16_t ckey = key
        cdef cmap[int16_t,float].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef float citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef float citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef float citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i16_float)

cdef class List__Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i16_float):
            self._cpp_obj = (<List__Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__i16_float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[int16_t,float]]] c_items):
        inst = <List__Map__i16_float>List__Map__i16_float.__new__(List__Map__i16_float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[int16_t,float]]] c_inst = make_unique[vector[cmap[int16_t,float]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)
                deref(c_inst).push_back(cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[int16_t,float]]] c_inst
        cdef cmap[int16_t,float] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[int16_t,float]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Map__i16_float.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[int16_t,float] citem = cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get()))
        cdef vector[cmap[int16_t,float]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[int16_t,float] citem
        for citem in deref(self._cpp_obj):
            yield Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[int16_t,float] citem
        cdef vector[cmap[int16_t,float]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[int16_t,float]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[int16_t,float] citem = cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get()))
        cdef vector[cmap[int16_t,float]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[int16_t,float]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[int16_t,float] citem = cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get()))
        cdef vector[cmap[int16_t,float]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i16_float)

cdef class Map__i16_Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_Map__i16_float):
            self._cpp_obj = (<Map__i16_Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i16_Map__i16_float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,cmap[int16_t,float]]] c_items):
        inst = <Map__i16_Map__i16_float>Map__i16_Map__i16_float.__new__(Map__i16_Map__i16_float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int16_t,cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int16_t,cmap[int16_t,float]]] c_inst = make_unique[cmap[int16_t,cmap[int16_t,float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)

                deref(c_inst).insert(cpair[int16_t,cmap[int16_t,float]](key,cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int16_t ckey = key
        cdef cmap[int16_t,cmap[int16_t,float]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[int16_t,float] citem = deref(iter).second
        return Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int16_t ckey = key
        cdef cmap[int16_t,cmap[int16_t,float]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[int16_t,float] citem = deref(iter).second
        return Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[int16_t,float] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef cmap[int16_t,float] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem)))



Mapping.register(Map__i16_Map__i16_float)

cdef class Set__Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Set__Map__i16_float):
            self._cpp_obj = (<Set__Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__Map__i16_float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[cmap[int16_t,float]]] c_items):
        inst = <Set__Map__i16_float>Set__Map__i16_float.__new__(Set__Map__i16_float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef unique_ptr[cset[cmap[int16_t,float]]] c_inst = make_unique[cset[cmap[int16_t,float]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)
                deref(c_inst).insert(cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(cmap[int16_t,float](deref(Map__i16_float(item)._cpp_obj.get()))))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield Map__i16_float.create(
    make_shared[cmap[int16_t,float]](citem))

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[cmap[int16_t,float]] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__Map__i16_float) and
                isinstance(other, Set__Map__i16_float)):
            cself = deref((<Set__Map__i16_float> self)._cpp_obj)
            cother = deref((<Set__Map__i16_float> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()
        for citem in deref((<Set__Map__i16_float> self)._cpp_obj):
            if deref((<Set__Map__i16_float> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__Map__i16_float.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()
        for citem in deref((<Set__Map__i16_float> self)._cpp_obj):
            if deref((<Set__Map__i16_float> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Map__i16_float.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()
        for citem in deref((<Set__Map__i16_float> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__Map__i16_float> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__Map__i16_float.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()
        for citem in deref((<Set__Map__i16_float> self)._cpp_obj):
            if deref((<Set__Map__i16_float> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__Map__i16_float> other)._cpp_obj):
            if deref((<Set__Map__i16_float> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Map__i16_float.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__Map__i16_float)

cdef class Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i64_double):
            self._cpp_obj = (<Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i64_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int64_t,double]] c_items):
        inst = <Map__i64_double>Map__i64_double.__new__(Map__i64_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int64_t,double]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int64_t,double]] c_inst = make_unique[cmap[int64_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int64_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst).insert(cpair[int64_t,double](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int64_t ckey = key
        cdef cmap[int64_t,double].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int64_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int64_t ckey = key
        cdef cmap[int64_t,double].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef double citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int64_t ckey
        cdef double citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i64_double)

cdef class Map__i16_Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_Map__i64_double):
            self._cpp_obj = (<Map__i16_Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i16_Map__i64_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,cmap[int64_t,double]]] c_items):
        inst = <Map__i16_Map__i64_double>Map__i16_Map__i64_double.__new__(Map__i16_Map__i64_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int16_t,cmap[int64_t,double]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int16_t,cmap[int64_t,double]]] c_inst = make_unique[cmap[int16_t,cmap[int64_t,double]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i64_double):
                    item = Map__i64_double(item)

                deref(c_inst).insert(cpair[int16_t,cmap[int64_t,double]](key,cmap[int64_t,double](deref(Map__i64_double(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int16_t ckey = key
        cdef cmap[int16_t,cmap[int64_t,double]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[int64_t,double] citem = deref(iter).second
        return Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int16_t ckey = key
        cdef cmap[int16_t,cmap[int64_t,double]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[int64_t,double] citem = deref(iter).second
        return Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[int64_t,double] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef cmap[int64_t,double] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem)))



Mapping.register(Map__i16_Map__i64_double)

cdef class Map__i32_Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Map__i64_double):
            self._cpp_obj = (<Map__i32_Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_Map__i64_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,cmap[int64_t,double]]] c_items):
        inst = <Map__i32_Map__i64_double>Map__i32_Map__i64_double.__new__(Map__i32_Map__i64_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,cmap[int64_t,double]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,cmap[int64_t,double]]] c_inst = make_unique[cmap[int32_t,cmap[int64_t,double]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i64_double):
                    item = Map__i64_double(item)

                deref(c_inst).insert(cpair[int32_t,cmap[int64_t,double]](key,cmap[int64_t,double](deref(Map__i64_double(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,cmap[int64_t,double]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[int64_t,double] citem = deref(iter).second
        return Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,cmap[int64_t,double]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[int64_t,double] citem = deref(iter).second
        return Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[int64_t,double] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef cmap[int64_t,double] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, Map__i64_double.create(
    make_shared[cmap[int64_t,double]](citem)))



Mapping.register(Map__i32_Map__i64_double)

cdef class List__float:
    def __init__(self, items=None):
        if isinstance(items, List__float):
            self._cpp_obj = (<List__float> items)._cpp_obj
        else:
            self._cpp_obj = move(List__float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[float]] c_items):
        inst = <List__float>List__float.__new__(List__float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[float]] _make_instance(object items) except *:
        cdef unique_ptr[vector[float]] c_inst = make_unique[vector[float]]()
        if items is not None:
            for item in items:
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[float]] c_inst
        cdef float citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[float]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__float.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef float citem = item
        cdef vector[float] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef float citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef float citem
        cdef vector[float] vec = deref(
            self._cpp_obj.get())
        cdef vector[float].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef float citem = item
        cdef vector[float] vec = deref(self._cpp_obj.get())
        cdef vector[float].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef float citem = item
        cdef vector[float] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__float)

cdef class Map__i16_List__float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_List__float):
            self._cpp_obj = (<Map__i16_List__float> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i16_List__float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,vector[float]]] c_items):
        inst = <Map__i16_List__float>Map__i16_List__float.__new__(Map__i16_List__float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int16_t,vector[float]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int16_t,vector[float]]] c_inst = make_unique[cmap[int16_t,vector[float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[float]")
                if not isinstance(item, List__float):
                    item = List__float(item)

                deref(c_inst).insert(cpair[int16_t,vector[float]](key,vector[float](deref(List__float(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int16_t ckey = key
        cdef cmap[int16_t,vector[float]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef vector[float] citem = deref(iter).second
        return List__float.create(
    make_shared[vector[float]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int16_t ckey = key
        cdef cmap[int16_t,vector[float]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef vector[float] citem = deref(iter).second
        return List__float.create(
    make_shared[vector[float]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[float] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield List__float.create(
    make_shared[vector[float]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef vector[float] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, List__float.create(
    make_shared[vector[float]](citem)))



Mapping.register(Map__i16_List__float)

cdef class Map__i32_List__float:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_List__float):
            self._cpp_obj = (<Map__i32_List__float> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_List__float._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,vector[float]]] c_items):
        inst = <Map__i32_List__float>Map__i32_List__float.__new__(Map__i32_List__float)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,vector[float]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,vector[float]]] c_inst = make_unique[cmap[int32_t,vector[float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[float]")
                if not isinstance(item, List__float):
                    item = List__float(item)

                deref(c_inst).insert(cpair[int32_t,vector[float]](key,vector[float](deref(List__float(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,vector[float]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef vector[float] citem = deref(iter).second
        return List__float.create(
    make_shared[vector[float]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,vector[float]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef vector[float] citem = deref(iter).second
        return List__float.create(
    make_shared[vector[float]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[float] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield List__float.create(
    make_shared[vector[float]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef vector[float] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, List__float.create(
    make_shared[vector[float]](citem)))



Mapping.register(Map__i32_List__float)

FloatFeatures = Map__i16_float
DoubleMapType = Map__i64_double
OldMapMap = Map__i16_Map__i64_double
NewMapMap = Map__i32_Map__i64_double
OldMapList = Map__i16_List__float
NewMapList = Map__i32_List__float
