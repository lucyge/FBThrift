/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/basic-cpp-async/gen-cpp/module_types.h"
#include "thrift/compiler/test/fixtures/basic-cpp-async/gen-cpp/module_data.h"

#include <algorithm>
#include <string.h>

#include <folly/Indestructible.h>



const typename _MyEnum_EnumMapFactory::ValuesToNamesMapType _MyEnum_VALUES_TO_NAMES = _MyEnum_EnumMapFactory::makeValuesToNamesMap();

const typename _MyEnum_EnumMapFactory::NamesToValuesMapType _MyEnum_NAMES_TO_VALUES = _MyEnum_EnumMapFactory::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::MyEnum>::size = 2;
template <>const folly::Range<const  ::MyEnum*> TEnumTraits< ::MyEnum>::values = folly::range( ::_MyEnumEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::MyEnum>::names = folly::range( ::_MyEnumEnumDataStorage::names);

template<>
const char* TEnumTraits< ::MyEnum>::findName( ::MyEnum value) {
  static const auto map = folly::Indestructible< ::_MyEnum_EnumMapFactory::ValuesToNamesMapType>{ ::_MyEnum_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::MyEnum>::findValue(const char* name,  ::MyEnum* out) {
  static const auto map = folly::Indestructible< ::_MyEnum_EnumMapFactory::NamesToValuesMapType>{ ::_MyEnum_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift


const uint64_t MyStruct::_reflection_id;
void MyStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_7958971832214294220(schema);
}

bool MyStruct::operator == (const MyStruct & rhs) const {
  if (!(this->MyIntField == rhs.MyIntField))
    return false;
  if (!(this->MyStringField == rhs.MyStringField))
    return false;
  return true;
}

void MyStruct::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "MyIntField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "MyStringField") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
};

void MyStruct::__clear() {
  MyIntField = 0;
  MyStringField = "";
  __isset.__clear();
}
void swap(MyStruct &a, MyStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.MyIntField, b.MyIntField);
  swap(a.MyStringField, b.MyStringField);
  swap(a.__isset, b.__isset);
}

void merge(const MyStruct& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(from.MyIntField, to.MyIntField);
  to.__isset.MyIntField = to.__isset.MyIntField || from.__isset.MyIntField;
  merge(from.MyStringField, to.MyStringField);
  to.__isset.MyStringField = to.__isset.MyStringField || from.__isset.MyStringField;
}

void merge(MyStruct&& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(std::move(from.MyIntField), to.MyIntField);
  to.__isset.MyIntField = to.__isset.MyIntField || from.__isset.MyIntField;
  merge(std::move(from.MyStringField), to.MyStringField);
  to.__isset.MyStringField = to.__isset.MyStringField || from.__isset.MyStringField;
}


