/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}




class ComplexUnion;

class VirtualComplexUnion;

typedef std::map<int16_t, std::string>  containerTypedef;

class ComplexUnion final : public apache::thrift::TStructType<ComplexUnion> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    intValue = 1,
    stringValue = 5,
    intListValue = 2,
    stringListValue = 3,
    typedefValue = 9,
    stringRef = 14,
  };

  ComplexUnion() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_intValue(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_stringValue(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_intListValue(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_stringListValue(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<9, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_typedefValue(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit ComplexUnion(
    ::apache::thrift::detail::argument_wrapper<14, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_stringRef(arg.move());
  }
  ComplexUnion(const ComplexUnion& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue: {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue: {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::intListValue: {
        set_intListValue(rhs.value_.intListValue);
        break;
      }
      case Type::stringListValue: {
        set_stringListValue(rhs.value_.stringListValue);
        break;
      }
      case Type::typedefValue: {
        set_typedefValue(rhs.value_.typedefValue);
        break;
      }
      case Type::stringRef: {
        set_stringRef(rhs.value_.stringRef);
        break;
      }
      default: assert(false);
    }
  }

  ComplexUnion& operator=(const ComplexUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue: {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue: {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::intListValue: {
        set_intListValue(rhs.value_.intListValue);
        break;
      }
      case Type::stringListValue: {
        set_stringListValue(rhs.value_.stringListValue);
        break;
      }
      case Type::typedefValue: {
        set_typedefValue(rhs.value_.typedefValue);
        break;
      }
      case Type::stringRef: {
        set_stringRef(rhs.value_.stringRef);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  ComplexUnion(ComplexUnion&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue: {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue: {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::intListValue: {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue: {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      case Type::typedefValue: {
        set_typedefValue(std::move(rhs.value_.typedefValue));
        break;
      }
      case Type::stringRef: {
        set_stringRef(std::move(rhs.value_.stringRef));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  ComplexUnion& operator=(ComplexUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue: {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue: {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::intListValue: {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue: {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      case Type::typedefValue: {
        set_typedefValue(std::move(rhs.value_.typedefValue));
        break;
      }
      case Type::stringRef: {
        set_stringRef(std::move(rhs.value_.stringRef));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::intValue: {
        
        break;
      }
      case Type::stringValue: {
        using namespace std; value_.stringValue.~string();
        break;
      }
      case Type::intListValue: {
        using namespace std; value_.intListValue.~vector<int64_t> ();
        break;
      }
      case Type::stringListValue: {
        using namespace std; value_.stringListValue.~vector<std::string> ();
        break;
      }
      case Type::typedefValue: {
        value_.typedefValue.~containerTypedef();
        break;
      }
      case Type::stringRef: {
        using namespace std; value_.stringRef.~string();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  ~ComplexUnion() noexcept {
    __clear();
  }

  union storage_type {
    int64_t intValue;
    std::string stringValue;
    std::vector<int64_t>  intListValue;
    std::vector<std::string>  stringListValue;
    containerTypedef typedefValue;
    std::string stringRef;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const ComplexUnion& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::intValue: {
        return value_.intValue == rhs.value_.intValue;

        break;
      }
      case Type::stringValue: {
        return value_.stringValue == rhs.value_.stringValue;

        break;
      }
      case Type::intListValue: {
        return value_.intListValue == rhs.value_.intListValue;

        break;
      }
      case Type::stringListValue: {
        return value_.stringListValue == rhs.value_.stringListValue;

        break;
      }
      case Type::typedefValue: {
        return value_.typedefValue == rhs.value_.typedefValue;

        break;
      }
      case Type::stringRef: {
        return value_.stringRef == rhs.value_.stringRef;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const ComplexUnion& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const ComplexUnion& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::intValue: {
        return value_.intValue < rhs.value_.intValue;

        break;
      }
      case Type::stringValue: {
        return value_.stringValue < rhs.value_.stringValue;

        break;
      }
      case Type::intListValue: {
        return value_.intListValue < rhs.value_.intListValue;

        break;
      }
      case Type::stringListValue: {
        return value_.stringListValue < rhs.value_.stringListValue;

        break;
      }
      case Type::typedefValue: {
        return value_.typedefValue < rhs.value_.typedefValue;

        break;
      }
      case Type::stringRef: {
        return value_.stringRef < rhs.value_.stringRef;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_intValue(T&&... t) {
    __clear();
    type_ = Type::intValue;
    new (&value_.intValue) int64_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    new (&value_.stringValue) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_intListValue(T&&... t) {
    __clear();
    type_ = Type::intListValue;
    new (&value_.intListValue) std::vector<int64_t> (std::forward<T>(t)...);
  }

  template<typename... T>
  void set_stringListValue(T&&... t) {
    __clear();
    type_ = Type::stringListValue;
    new (&value_.stringListValue) std::vector<std::string> (std::forward<T>(t)...);
  }

  template<typename... T>
  void set_typedefValue(T&&... t) {
    __clear();
    type_ = Type::typedefValue;
    new (&value_.typedefValue) containerTypedef(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_stringRef(T&&... t) {
    __clear();
    type_ = Type::stringRef;
    new (&value_.stringRef) std::string(std::forward<T>(t)...);
  }

  const int64_t& get_intValue() const {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  const std::string& get_stringValue() const {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  const std::vector<int64_t> & get_intListValue() const {
    assert(type_ == Type::intListValue);
    return value_.intListValue;
  }

  const std::vector<std::string> & get_stringListValue() const {
    assert(type_ == Type::stringListValue);
    return value_.stringListValue;
  }

  const containerTypedef& get_typedefValue() const {
    assert(type_ == Type::typedefValue);
    return value_.typedefValue;
  }

  const std::string& get_stringRef() const {
    assert(type_ == Type::stringRef);
    return value_.stringRef;
  }

  int64_t& mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  std::string& mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  std::vector<int64_t> & mutable_intListValue() {
    assert(type_ == Type::intListValue);
    return value_.intListValue;
  }

  std::vector<std::string> & mutable_stringListValue() {
    assert(type_ == Type::stringListValue);
    return value_.stringListValue;
  }

  containerTypedef& mutable_typedefValue() {
    assert(type_ == Type::typedefValue);
    return value_.typedefValue;
  }

  std::string& mutable_stringRef() {
    assert(type_ == Type::stringRef);
    return value_.stringRef;
  }

  int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  std::vector<int64_t>  move_intListValue() {
    assert(type_ == Type::intListValue);
    return std::move(value_.intListValue);
  }

  std::vector<std::string>  move_stringListValue() {
    assert(type_ == Type::stringListValue);
    return std::move(value_.stringListValue);
  }

  containerTypedef move_typedefValue() {
    assert(type_ == Type::typedefValue);
    return std::move(value_.typedefValue);
  }

  std::string move_stringRef() {
    assert(type_ == Type::stringRef);
    return std::move(value_.stringRef);
  }

  Type getType() const { return type_; }

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
 private:
  Type type_;
  storage_type value_;

};

class VirtualComplexUnion : public apache::thrift::TStructType<VirtualComplexUnion> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    thingOne = 1,
    thingTwo = 2,
  };

  VirtualComplexUnion() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit VirtualComplexUnion(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_thingOne(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit VirtualComplexUnion(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_thingTwo(arg.move());
  }
  VirtualComplexUnion(const VirtualComplexUnion& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::thingOne: {
        set_thingOne(rhs.value_.thingOne);
        break;
      }
      case Type::thingTwo: {
        set_thingTwo(rhs.value_.thingTwo);
        break;
      }
      default: assert(false);
    }
  }

  VirtualComplexUnion& operator=(const VirtualComplexUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::thingOne: {
        set_thingOne(rhs.value_.thingOne);
        break;
      }
      case Type::thingTwo: {
        set_thingTwo(rhs.value_.thingTwo);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  VirtualComplexUnion(VirtualComplexUnion&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::thingOne: {
        set_thingOne(std::move(rhs.value_.thingOne));
        break;
      }
      case Type::thingTwo: {
        set_thingTwo(std::move(rhs.value_.thingTwo));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  VirtualComplexUnion& operator=(VirtualComplexUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::thingOne: {
        set_thingOne(std::move(rhs.value_.thingOne));
        break;
      }
      case Type::thingTwo: {
        set_thingTwo(std::move(rhs.value_.thingTwo));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::thingOne: {
        using namespace std; value_.thingOne.~string();
        break;
      }
      case Type::thingTwo: {
        using namespace std; value_.thingTwo.~string();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~VirtualComplexUnion() noexcept {
    __clear();
  }

  union storage_type {
    std::string thingOne;
    std::string thingTwo;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const VirtualComplexUnion& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::thingOne: {
        return value_.thingOne == rhs.value_.thingOne;

        break;
      }
      case Type::thingTwo: {
        return value_.thingTwo == rhs.value_.thingTwo;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const VirtualComplexUnion& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const VirtualComplexUnion& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::thingOne: {
        return value_.thingOne < rhs.value_.thingOne;

        break;
      }
      case Type::thingTwo: {
        return value_.thingTwo < rhs.value_.thingTwo;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_thingOne(T&&... t) {
    __clear();
    type_ = Type::thingOne;
    new (&value_.thingOne) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_thingTwo(T&&... t) {
    __clear();
    type_ = Type::thingTwo;
    new (&value_.thingTwo) std::string(std::forward<T>(t)...);
  }

  const std::string& get_thingOne() const {
    assert(type_ == Type::thingOne);
    return value_.thingOne;
  }

  const std::string& get_thingTwo() const {
    assert(type_ == Type::thingTwo);
    return value_.thingTwo;
  }

  std::string& mutable_thingOne() {
    assert(type_ == Type::thingOne);
    return value_.thingOne;
  }

  std::string& mutable_thingTwo() {
    assert(type_ == Type::thingTwo);
    return value_.thingTwo;
  }

  std::string move_thingOne() {
    assert(type_ == Type::thingOne);
    return std::move(value_.thingOne);
  }

  std::string move_thingTwo() {
    assert(type_ == Type::thingTwo);
    return std::move(value_.thingTwo);
  }

  Type getType() const { return type_; }

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
 private:
  Type type_;
  storage_type value_;

};



