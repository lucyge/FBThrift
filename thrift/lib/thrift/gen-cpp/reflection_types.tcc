/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "thrift/lib/thrift/gen-cpp/reflection_types.h"

#include "thrift/lib/thrift/gen-cpp/reflection_reflection.h"

namespace apache { namespace thrift { namespace reflection {

template <class Protocol_>
uint32_t StructField::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_214309804125196972(*schema);
    iprot->setNextStructType(StructField::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isRequired);
          this->__isset.isRequired = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->annotations.clear();
            uint32_t _size1;
            bool _sizeUnknown2;
            apache::thrift::protocol::TType _ktype3 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype4 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size1, _sizeUnknown2);
            if (!_sizeUnknown2) {
              uint32_t _i7;
              for (_i7 = 0; _i7 < _size1; ++_i7)
              {
                std::string _key8;
                xfer += iprot->readString(_key8);
                std::string& _val9 = this->annotations[_key8];
                xfer += iprot->readString(_val9);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key10;
                xfer += iprot->readString(_key10);
                std::string& _val11 = this->annotations[_key10];
                xfer += iprot->readString(_val11);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t StructField::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructField");
  xfer += oprot->writeFieldBegin("isRequired", apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isRequired);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("type", apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.annotations) {
    xfer += oprot->writeFieldBegin("annotations", apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRING, this->annotations.size());
      std::unordered_map<std::string, std::string> ::const_iterator _iter12;
      for (_iter12 = this->annotations.begin(); _iter12 != this->annotations.end(); ++_iter12)
      {
        xfer += oprot->writeString(_iter12->first);
        xfer += oprot->writeString(_iter12->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("order", apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->order);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t DataType::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_4733295045172396908(*schema);
    iprot->setNextStructType(DataType::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fields.clear();
            uint32_t _size14;
            bool _sizeUnknown15;
            apache::thrift::protocol::TType _ktype16 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype17 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype16, _vtype17, _size14, _sizeUnknown15);
            if (!_sizeUnknown15) {
              uint32_t _i20;
              for (_i20 = 0; _i20 < _size14; ++_i20)
              {
                int16_t _key21;
                xfer += iprot->readI16(_key21);
                StructField& _val22 = this->fields[_key21];
                xfer += _val22.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int16_t _key23;
                xfer += iprot->readI16(_key23);
                StructField& _val24 = this->fields[_key23];
                xfer += _val24.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mapKeyType);
          this->__isset.mapKeyType = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->valueType);
          this->__isset.valueType = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->enumValues.clear();
            uint32_t _size25;
            bool _sizeUnknown26;
            apache::thrift::protocol::TType _ktype27 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype28 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size25, _sizeUnknown26);
            if (!_sizeUnknown26) {
              uint32_t _i31;
              for (_i31 = 0; _i31 < _size25; ++_i31)
              {
                std::string _key32;
                xfer += iprot->readString(_key32);
                int32_t& _val33 = this->enumValues[_key32];
                xfer += iprot->readI32(_val33);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key34;
                xfer += iprot->readString(_key34);
                int32_t& _val35 = this->enumValues[_key34];
                xfer += iprot->readI32(_val35);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.enumValues = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t DataType::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DataType");
  xfer += oprot->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I16, apache::thrift::protocol::T_STRUCT, this->fields.size());
      std::unordered_map<int16_t, StructField> ::const_iterator _iter36;
      for (_iter36 = this->fields.begin(); _iter36 != this->fields.end(); ++_iter36)
      {
        xfer += oprot->writeI16(_iter36->first);
        xfer += _iter36->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mapKeyType) {
    xfer += oprot->writeFieldBegin("mapKeyType", apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->mapKeyType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.valueType) {
    xfer += oprot->writeFieldBegin("valueType", apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->valueType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enumValues) {
    xfer += oprot->writeFieldBegin("enumValues", apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->enumValues.size());
      std::unordered_map<std::string, int32_t> ::const_iterator _iter37;
      for (_iter37 = this->enumValues.begin(); _iter37 != this->enumValues.end(); ++_iter37)
      {
        xfer += oprot->writeString(_iter37->first);
        xfer += oprot->writeI32(_iter37->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t Schema::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_6902704939566307148(*schema);
    iprot->setNextStructType(Schema::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->dataTypes.clear();
            uint32_t _size39;
            bool _sizeUnknown40;
            apache::thrift::protocol::TType _ktype41 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype42 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size39, _sizeUnknown40);
            if (!_sizeUnknown40) {
              uint32_t _i45;
              for (_i45 = 0; _i45 < _size39; ++_i45)
              {
                int64_t _key46;
                xfer += iprot->readI64(_key46);
                DataType& _val47 = this->dataTypes[_key46];
                xfer += _val47.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int64_t _key48;
                xfer += iprot->readI64(_key48);
                DataType& _val49 = this->dataTypes[_key48];
                xfer += _val49.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dataTypes = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->names.clear();
            uint32_t _size50;
            bool _sizeUnknown51;
            apache::thrift::protocol::TType _ktype52 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype53 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype52, _vtype53, _size50, _sizeUnknown51);
            if (!_sizeUnknown51) {
              uint32_t _i56;
              for (_i56 = 0; _i56 < _size50; ++_i56)
              {
                std::string _key57;
                xfer += iprot->readString(_key57);
                int64_t& _val58 = this->names[_key57];
                xfer += iprot->readI64(_val58);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key59;
                xfer += iprot->readString(_key59);
                int64_t& _val60 = this->names[_key59];
                xfer += iprot->readI64(_val60);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t Schema::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Schema");
  xfer += oprot->writeFieldBegin("dataTypes", apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I64, apache::thrift::protocol::T_STRUCT, this->dataTypes.size());
    std::unordered_map<int64_t, DataType> ::const_iterator _iter61;
    for (_iter61 = this->dataTypes.begin(); _iter61 != this->dataTypes.end(); ++_iter61)
    {
      xfer += oprot->writeI64(_iter61->first);
      xfer += _iter61->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("names", apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I64, this->names.size());
    std::unordered_map<std::string, int64_t> ::const_iterator _iter62;
    for (_iter62 = this->names.begin(); _iter62 != this->names.end(); ++_iter62)
    {
      xfer += oprot->writeString(_iter62->first);
      xfer += oprot->writeI64(_iter62->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

}}} // namespace

